# How to Use Python: Your First Steps

> by Leodanis Pozo Ramos, Oct 13, 2025

- <https://realpython.com/python-first-steps/>

- [How to Use Python: Your First Steps](#how-to-use-python-your-first-steps)
  - [Why Should You Use Python?](#why-should-you-use-python)
  - [How Do You Install and Run Python?](#how-do-you-install-and-run-python)
  - [How to Use Python: What’s the Basic Syntax?](#how-to-use-python-whats-the-basic-syntax)
    - [Comments](#comments)
    - [Variables](#variables)
    - [Keywords](#keywords)
    - [Built-in Data Types](#built-in-data-types)
      - [Numbers](#numbers)
      - [Booleans](#booleans)
    - [Sequence Types](#sequence-types)
    - [Strings](#strings)
    - [Bytes](#bytes)
    - [Bytearrays](#bytearrays)
    - [Lists](#lists)
      - [Create a list](#create-a-list)
      - [Access list elements](#access-list-elements)
      - [List concatenation](#list-concatenation)
      - [Modify list elements](#modify-list-elements)
    - [Tuples](#tuples)
      - [Create a tuple](#create-a-tuple)
      - [Access tuple elements](#access-tuple-elements)
      - [Tuple concatenation](#tuple-concatenation)
      - [Create a list from a tuple](#create-a-list-from-a-tuple)
  - [Loops](#loops)
    - [`for` Loops](#for-loops)
    - [`while` Loops](#while-loops)

## Why Should You Use Python?

- [Why Should You Use Python?](https://realpython.com/python-first-steps/#why-should-you-use-python)

## How Do You Install and Run Python?

- [How Do You Install and Run Python?](https://realpython.com/python-first-steps/#how-do-you-install-and-run-python)

## How to Use Python: What’s the Basic Syntax?

- [How to Use Python: What’s the Basic Syntax?](https://realpython.com/python-first-steps/#how-to-use-python-whats-the-basic-syntax)

### Comments

- [Comments](https://realpython.com/python-first-steps/#comments)

### Variables

- [Variables](https://realpython.com/python-first-steps/#variables)

### Keywords

- [Keywords](https://realpython.com/python-first-steps/#keywords)

### Built-in Data Types

- [Built-in Data Types](https://realpython.com/python-first-steps/#built-in-data-types)

- Python has a handful of **built-in data types**, such as  
  - [numbers](https://realpython.com/python-numbers/) (integers, floats, and complex numbers),
  - [Booleans](https://realpython.com/python-boolean/),
  - [strings](https://realpython.com/python-strings/),
  - [bytes](https://realpython.com/python-bytes/),
  - [lists](https://realpython.com/python-list/),
  - [tuples](https://realpython.com/python-tuple/),
  - [dictionaries](https://realpython.com/python-dicts/), and
  - [sets](https://realpython.com/python-sets/).

- You can **manipulate** the *built-in data types* using different tools.  
  … Here are some of them:
  - [Operators](https://realpython.com/python-operators-expressions/)
  - [Built-in functions](https://realpython.com/python-built-in-functions/)
  - [Methods](https://realpython.com/instance-class-and-static-methods-demystified/)

#### Numbers

- [Numbers](https://realpython.com/python-first-steps/#numbers)

  ``` Python
  >>> # Addition
  ... 5 + 3
  8
  >>> # Subtraction
  ... 5 - 3
  2
  >>> # Multiplication
  ... 5 * 3
  15
  >>> # True division
  ... 5 / 3
  1.6666666666666667
  >>> # Floor division
  ... 5 // 3
  1
  >>> # Modulus (returns the remainder from division)
  ... 5 % 3
  2
  >>> # Power
  ... 5 ** 3
  125
  ```

  ``` Python
  >>> # The built-in function 'float()' returns floating-point number
  ... float(42)
  42.0
  >>> float(42.5)
  42.5
  >>> sum = float(42.5) + 42.5
  >>> type(sum)
  <class 'float'>
  >>> sum
  85.0
  >>> float("42.5")
  42.5
  ```

  ``` Python
  >>> # The built-in function 'complex()' returns complex numbers
  ... c1 = complex(1,2)
  >>> type(c1)
  <class 'complex'>
  >>> c1
  (1+2j)
  >>> c2 = complex(2,4)
  >>> c1 + c2
  (3+6j)  
  ```

  ``` Python
  >>> # The built in function 'int()' returns integer numbers
  ... i1 = int(42)
  >>> type(i1)
  <class 'int'>
  >>> i1
  42
  >>> int("42") + int(42) + 42
  126
  ```

#### Booleans

- [Booleans](https://realpython.com/python-first-steps/#booleans)

  ``` Python
  >>> # The built-in 'bool()' function returns 'True' or 'False' a
  ... bool(0)
  False
  >>> bool('')
  False
  >>> bool(' ')
  True
  >>> bool('a')
  True
  >>> bool([])
  False
  >>> bool([1, 2])
  True
  ```  

  The [`bool()`](https://docs.python.org/3/library/functions.html#bool) function takes an *object* as an argument  
  … and returns`True` or `False`  
  … according to the object's truth testing rules.

  > By default, an object is considered *true* unless its class defines  
  … either a `__bool__()` method that returns `False`  
  … or a `__len__()` method that returns *zero*,  
  … when called with the object.
  >
  > Here are most of the built-in objects considered *false*:
  >
  > - constants defined to be *false*: `None` and `False`
  > - *zero* of any *numeric type*: `0`, `0.0`, `0j`, `Decimal(0)`, `Fraction(0, 1)`
  > - *empty* sequences and collections: `''`, `()`, `[]`, `{}`, `set()`, `range(0)`

### Sequence Types

- see <https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range>

- There are three basic sequence types:
  - [lists](#lists),
  - [tuples](#tuples), and
  - [range](https://docs.python.org/3/library/stdtypes.html#range) objects.

- There are additional sequence types tailored for special purposes:  
  - binary data: [`bytes`](#bytes) and [`bytearrays`](#bytearrays)
  - text [strings](#strings) are described in dedicated sections.

- There are some [common sequence operations](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations) like `len(seq)` and concatenation with the `+` operation.

### Strings

- see [Strings and Character Data in Python](https://realpython.com/python-strings/) and built-in [**`str`** data type](https://realpython.com/ref/builtin-types/str/).

  > The *built-in* [`str` data type](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str) represents **sequences of characters** and is used to manipulate textual data. Python strings are **immutable sequences**, meaning once defined, they can’t be changed.

- Strings are *pieces of text* or *[sequences](https://realpython.com/ref/glossary/sequence/) (collection of ordered objects, where each object has an associated integer index) of characters* that you can define using single, double, or triple quotes

  As with other *sequences*, you can **retrieve individual** characters from a string using their **index**.  
  
  An *index* is a [**zero-based integer**](https://en.wikipedia.org/wiki/Zero-based_numbering) associated with the **position** of a value in a sequence:

  ``` Python
  >>> welcome = "Welcome John Doe"
  >>> welcome[1]
  'e'
  >>> welcome[-2]
  'o'
  >>> welcome[8:12] # slice
  'John'
  >>> welcome[8:12:2] # slice
  'Jh'  
  ```  

  The syntax (`welcome[-2]`) runs an [*indexing operation*](https://realpython.com/ref/glossary/indexing/)  
  … that *retrieves the character* at the position indicated by the *target index*.
  
  Note that a **negative** *index* retrieves the element in **reverse order**,  
  … with `-1` being the index of the **last** character in the string.

  You can also retrieve a **part** of a string by [**slicing**](https://realpython.com/ref/glossary/slicing/) it.  
  … *Slicing* operations follow the syntax **`[start:end:step]`**.  
  … Here, `start` is the index of the *first value to **include*** in the slice,  
  … and `end` is the index of the *last value, which **isn’t included*** in the returned slice.

  Finally, `step` is an *optional* integer representing the number of values **to jump over**  
  … while extracting the values from the original string.  
  … A step of `2`, for example, will return *every other* (*jedes zweite*) element between `start` and `stop`.

- You can also use a **backslash (`\`) to escape characters** with special meaning, such as the *quotes* themselves.

- The plus operator (**`+`**) **concatenates** strings into a single string.  
  … You should consider using the [**`.join()`**](https://realpython.com/python-join-string/) method, which is *more efficient*.

  see [How to Join Strings in Python](https://realpython.com/python-join-string/)

- Python’s **f-strings** are an improved string **formatting** syntax.  
  … They’re string literals with an **`f`** at the beginning, *outside the quotes*.  
  … Expressions that appear in **embedded curly braces (`{}`)**  
  … are **replaced with their values** in the formatted string.

  see [Python's F-String for String Interpolation and Formatting](https://realpython.com/python-f-strings/)

### Bytes

- see <https://realpython.com/python-first-steps/#bytes-and-bytearrays>

- [bytes](https://realpython.com/ref/builtin-types/bytes/) represent ***immutable** sequences of raw 8-bit values or integers in the range 0 to 255*.

- While [`str`](#strings) stores **Unicode text**,  
  `bytes` objects store the **encoded form** of that text or *arbitrary binary payloads*.

- Creating `byte` objects:

  ``` Python
  >>> # Literal syntax for a `byte` object (ASCII only)
  ... b"Hello"
  b'Hello'
  >>> # From an iterabel of integers (0 to 255)
  ... bytes([72, 101, 108, 108, 111])
  b'Hello'
  >>> # By encoding a string
  ... "café".encode("utf-8")
  b'caf\xc3\xa9'
  ```

- Turn a `byte` object back into a *string*

  ``` Python
  >>> # Turn a byte object back into a string
  ... data = b'caf\xc3\xa9'
  >>> data.decode("utf-8")
  'café'
  ```

- Like other *sequences*, `bytes` support `len()` and *slicing*

  ``` Python
  vscode ➜ /workspaces/__learn-python-02-blogs (main) $ python
  Python 3.14.0 (main, Oct  8 2025, 21:26:42) [GCC 14.2.0] on linux
  >>> packet = b"ABCDEF"
  >>> len(packet)
  6
  # Indexing returns an integer representing the byte value, rather than a one-byte `bytes` object
  >>> first = packet[0]
  >>> type(first)
  <class 'int'>
  >>> first
  65  
  >>> first_to_third = packet[1:4]
  >>> type(first_to_third)
  <class 'bytes'>
  >>> first_to_third
  b'BCD'  
  ```

- `bytes` can literally only be created from ASCII characters  
  and provides the handy methods `.hex()` and `fromhex()` to convert byte values to and from their hexadecimal string representation
  
  ``` Python
  >>> chrs = b"üÜöÖä".hex()
    File "<python-input-12>", line 1
      chrs = b"üÜöÖä".hex()
            ^^^^^^^^
  SyntaxError: bytes can only contain ASCII literal characters
  >>> chrs = b"aAoO".hex()
  >>> chrs
  '61416f4f'
  >>> bytes.fromhex(chrs)
  b'aAoO'
  >>> 
  ```

- To learn more about working with binary data, check out  
  [Bytes Objects: Handling Binary Data in Python](https://realpython.com/python-bytes/) and  
  [Python’s bytearray : A Mutable Sequence of Bytes](https://realpython.com/python-bytearray/)

### Bytearrays

- Python’s `bytes` is an **immutable** data type. If you need a **mutable sequence of bytes**, then use the [`bytearray`](https://realpython.com/ref/builtin-types/bytearray/) data type, which is a **mutable array of bytes**:

  ``` Python
  vscode ➜ /workspaces/__learn-python-02-blogs (main) $ python
  Python 3.14.0 (main, Oct  8 2025, 21:26:42) [GCC 14.2.0] on linux
  >>> buffer = bytearray(b"ABCDEF")
  >>> lower_a = b"a"
  >>> lower_a
  b'a'
  >>> lower_a.decode("utf-8")
  'a'
  # ERROR! We have to assign the corresponding integer value
  >>> buffer[0] = lower_a
  Traceback (most recent call last):
    File "<python-input-8>", line 1, in <module>
      buffer[0] = lower_a
      ~~~~~~^^^
  TypeError: 'bytes' object cannot be interpreted as an integer
  # One way to get the integer value of a bytes object
  >>> buffer[0] = list(lower_a)[0]
  >>> buffer
  bytearray(b'aBCDEF')
  ```

### Lists

- see <https://realpython.com/python-first-steps/#lists> and <https://docs.python.org/3/library/stdtypes.html#list>

- [Lists](https://realpython.com/ref/builtin-types/list/) are [**mutable sequences**](https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types) that **group various objects** together.

#### Create a list

- Sequence of comma-separated objects in **square brackets []**

  ``` Python
  vscode ➜ /workspaces/__learn-python-02-blogs/01.real-python (main) $ python3
  Python 3.14.0 (main, Oct  8 2025, 21:26:42) [GCC 14.2.0] on linux
  Type "help", "copyright", "credits" or "license" for more information.
  >>> # Define an empty list
  >>> empty = []
  >>> empty
  []
  >>> # Define a list of numbers
  >>> numbers = [1, 3.14, 42, 666]
  >>> numbers
  [1, 3.14, 42, 666]
  >>> # Modify the list in place
  >>> numbers[0] = 'one'
  >>> numbers
  ['one', 3.14, 42, 666]
  >>> # Define a list of objects with different data types
  >>> a_list = ["six", 666, 6.66, ['a', 'b', 'c'], complex(1,2)]
  >>> for e in a_list:
  ...     print(f"{e}: {type(e)} ")
  ...     
  six: <class 'str'> 
  666: <class 'int'> 
  6.66: <class 'float'> 
  ['a', 'b', 'c']: <class 'list'> 
  (1+2j): <class 'complex'>  
  ```

#### Access list elements

- Lists are sequences like [strings](#strings), so you can access their individual items using **zero-based integer indices**.

  ``` Python
  >>> numbers = [1, 3.14, 42, 666]
  >>> numbers[1]
  3.14
  >>> type(numbers[1])
  <class 'float'>
  >>> numbers[-1]
  666
  >>> numbers[-2]
  42
  >>> numbers[-5]
  Traceback (most recent call last):
    File "<python-input-17>", line 1, in <module>
      numbers[-5]
      ~~~~~~~^^^^
  IndexError: list index out of range
  >>> a_list = ["six", 666, 6.66, ['a', 'b', 'c'], complex(1,2)]
  >>> a_list[-2][1]
  'b'
  >>> a_list[0][2]
  'x'  
  ```

- **Negative indices** retrieve items in **reverse order**, starting from the last item at index `-1`.

- If you **nest a list**, a `string`, or any *other sequence* within a list, then you can **access the inner items** using **multiple indices in a row**.

- A `list` is a [**sequence type**](#sequence-types) therefore it provides a `len(seq)` operation.

#### List concatenation

- Lists can be concatenated by using the [**plus (`+`) operator**](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations) which returns a **new** `list` object containing all the items from the original lists.

#### Modify list elements

- Because lists are mutable sequences, you can modify them in place using **index notation** and [**assignment** operation](https://realpython.com/python-assignment-operator/)

  ``` Python
  vscode ➜ /workspaces/__learn-python-02-blogs/01.real-python (main) $ python3
  Python 3.14.0 (main, Oct  8 2025, 21:26:42) [GCC 14.2.0] on linux
  Type "help", "copyright", "credits" or "license" for more information.
  >>> numbers = [1, 3.14, 42, 666]
  >>> # Modify the list in place
  >>> numbers[0] = 'one'
  >>> numbers
  ['one', 3.14, 42, 666]
  ```

- Commonly used list methods

  - [`.append()`](https://docs.python.org/3/library/stdtypes.html#sequence.append)  
    see also <https://realpython.com/python-append/>
  - [`.sort()`](https://docs.python.org/3/library/stdtypes.html#list.sort)  
    see also <https://realpython.com/python-sort/>
  - [`.pop()`](https://docs.python.org/3/library/stdtypes.html#sequence.pop)

  ``` Python
  >>> a_list = ['a', "six", 42, 3.14, complex(1,2)]
  >>> a_list
  ['a', 'six', 42, 3.14, (1+2j)]
  >>> len(a_list)
  5
  >>> a_list.append([0, 1, 2, 3, 5,8]) # .append()
  >>> a_list
  ['a', 'six', 42, 3.14, (1+2j), [0, 1, 2, 3, 5, 8]]
  >>> len(a_list)
  6
  >>> fibo = a_list.pop()              # .pop()
  >>> a_list
  ['a', 'six', 42, 3.14, (1+2j)]
  >>> len(a_list)
  5
  >>> fibo
  [0, 1, 2, 3, 5, 8]
  >>> a_list.sort()                    # .sort() ✘ 
  Traceback (most recent call last):
    File "<python-input-33>", line 1, in <module>
      a_list.sort()
      ~~~~~~~~~~~^^
  TypeError: '<' not supported between instances of 'int' and 'str'
  >>> fruits = ["oranges", "apples", "grapes", "blueberries"]
  >>> fruits.sort()                    # .sort() ✔
  >>> fruits
  ['apples', 'blueberries', 'grapes', 'oranges']
  ```

### Tuples

- see <https://realpython.com/python-first-steps/#tuples> and <https://docs.python.org/3/library/stdtypes.html#tuple>

- Tuples are [**imutable sequences**](https://realpython.com/python-mutable-vs-immutable-types/#immutable-built-in-data-types-in-python)

#### Create a tuple

- **Note** that to *create a tuple* object, you only need a **series of comma-separated values**. You **DON’T need** to include *parentheses*.

  ``` Python
  vscode ➜ /workspaces/__learn-python-02-blogs (main) $ python3
  Python 3.14.0 (main, Oct  8 2025, 21:26:42) [GCC 14.2.0] on linux
  Type "help", "copyright", "credits" or "license" for more information.
  Ctrl click to launch VS Code Native REPL
  >>> # Creating a tuple from a comma separated sequence of literal values
  >>> employee = "Jane", "Doe", 31, "Sofware Developer"
  >>> employee
  ('Jane', 'Doe', 31, 'Sofware Developer')
  >>> employee[0]
  'Jane'
  >>> # This doesn't work because a tuple is a immutable sequence
  >>> employee[0] = "John"
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
      employee[0] = "John"
      ~~~~~~~~^^^
  TypeError: 'tuple' object does not support item assignment
  ```

- However, using the *parentheses to delimit a tuple* makes your code **more readable and explicit**.

  ``` Python
  >>> employee = ("John", "Doe", 42, "Programmer")
  >>> employee = "Jane", "Doe", 31, "Sofware Developer"
  >>> type(employee)
  <class 'tuple'>
  >>> employee2 = ("John", "Doe", 42, "Programmer")
  >>> type(employee2)
  <class 'tuple'>
  >>> # When you need to create a single-element tuple, the comma after the value is obligatory.
  >>> tuple_1 = 1,
  >>> type(tuple_1)
  <class 'tuple'>
  >>> tuple_1 = 1
  >>> type(tuple_1)
  <class 'int'>
  >>> 
  ```

#### Access tuple elements

- Just like *lists*, you can also do **indexing** and **slicing** with tuples.

  ``` Python
  >>> employee = (42, "John", "Doe", "Programmer")
  >>> employee[1]
  'John'
  >>> employee[1:3]
  ('John', 'Doe')
  >>> employee[-2]
  'Doe'  
  >>> len(employee)
  4  
  ```

- Again, a `tuple` is a [**sequence type**](#sequence-types) therefore it provides a `len(seq)` operation.

#### Tuple concatenation

- A *concatenation operation* with more than one `tuple` creates a **new `tuple`** containing all the items from all input tuples.

  ``` Python
  >>> one = (1,)
  >>> two_to_three = (2, 3)
  >>> four_to_six = (4, 5, 6)
  >>> one_to_six = one + two_to_three + four_to_six
  >>> type(one_to_six)
  <class 'tuple'>
  >>> one_to_six
  (1, 2, 3, 4, 5, 6)  
  ```

#### Create a list from a tuple

- The [`list` *type constructor*](https://docs.python.org/3/library/stdtypes.html#list) can create a list from an [*iterable*](https://docs.python.org/3/glossary.html#term-iterable). *Tuples* are *iterables*.

  ``` Python
  >>> numbers_as_tuple = (1, 2, 3)
  >>> numbers_as_list = list(numbers_as_tuple)
  >>> type(numbers_as_tuple)
  <class 'tuple'>
  >>> type(numbers_as_list)
  <class 'list'>
  >>> numbers_as_list[1] = 42
  >>> numbers_as_list[1]
  42
  >>> numbers_as_tuple[1]
  2
  ```  

- Because *tuples* are **immutable sequences**, many of the methods that are available for *lists* **DON’T exist on** *tuples*.  
  
  Tuples have only two (*sequence*) methods:  
  - [`.count()`](https://docs.python.org/3/library/stdtypes.html#sequence.count)
  - [`.index()`](https://docs.python.org/3/library/stdtypes.html#sequence.index)

  ``` Python
  >>> letters = ("a", "b", "b", "a", "c", "a")
  >>> letters.count("a")
  3
  >>> letters.count("c")
  1
  >>> letters.index("b")
  1  
  ```

### Dictionaries

- see <https://realpython.com/python-first-steps/#built-in-data-types>, <https://docs.python.org/3/library/stdtypes.html#mapping-types-dict> and <https://realpython.com/python-dicts/>

- Python [**dictionaries**](https://realpython.com/ref/glossary/dictionary/) are [**associative arrays**](https://en.wikipedia.org/wiki/Associative_array)  
  … containing a collection of **key-value pairs**,  
  … where each key must be a [**hashable object**](https://realpython.com/ref/glossary/hashable/) that maps to an arbitrary value.

#### Create a dictionary

- Some ways to create a dictionary  
  see <https://docs.python.org/3/library/stdtypes.html#dict> for `dict` *type constructor*

  ``` Python
  >>> # Creating a dictionary from a literal
  >>> john = {"name": "John Doe", "age": 42, "job": "Programmer" }
  >>> type(john)
  <class 'dict'>
  >>> john
  {'name': 'John Doe', 'age': 42, 'job': 'Programmer'}
  >>> # Creating a dictonary using the dict type constructor
  >>> jane = dict(name="Jane Doe", age=24, job="Web Developer")
  >>> type(jane)
  <class 'dict'>
  >>> jane
  {'name': 'Jane Doe', 'age': 24, 'job': 'Web Developer'}
  ```

## Loops

- see [Loops](https://realpython.com/python-first-steps/#loops)

### `for` Loops

- Python’s `for` loops are designed  
  … to **iterate over the items in a collection**,  
  … such as *lists*, *tuples*, *strings*, and *dictionaries*.
  
- see [Python for Loops: The Pythonic Way](https://realpython.com/python-for-loop/)

- Syntax

  ``` Python
  for loop_var in iterable:
      # Repeat this code block until iterable is exhausted
      # Do something with loop_var...
      if break_condition:
          break  # Leave the loop
      if continue_condition:
          continue  # Resume the loop without running the remaining code
      # Remaining code...
  else:
      # Run this code block if no break statement is run
  ```

  You commonly use an **`else` clause** in *loops*  
  … that include *at least one* [**break statement**](https://realpython.com/python-break/) in their code block.  
  … Otherwise, there’s no need for it.

- Example
  
  ``` Python
  # 01.real-python/py_01_for_loop_demo.py
  def do_for_loop(iterable):
    for loop_var in iterable:
      upper = loop_var.upper()
      if upper == 'STOP':
        break
      if upper == 'CONT':
        continue
      print(upper)
    else:
      print('no break occured')
  ```

- REPL
  
  ``` Python
  # …/__learn-python-02-blogs/01.real-python> python3
  >>> import importlib
  >>> import py_01_for_loop_demo as demo  
  >>> demo.do_for_loop(['aaa', 'bbb', 'cont', 'stop', 'ccc'])
  AAA
  BBB
  >>> demo.do_for_loop(['aaa', 'bbb', 'cont', 'ccc'])
  AAA
  BBB
  CCC
  no break occured
  >>> demo.do_for_loop([])
  no break occured  
  ```

### `while` Loops

- In contrast, `while` loops are useful  
  … when you need **to execute a block of code repeatedly**  
  … as long as a given condition remains true.

- see [Python while Loops: Repeating Tasks Conditionally](https://realpython.com/python-while-loop/)

- You typically use a **`while`** loop when you **don’t know beforehand how many iterations you need**  
  … to complete a given operation.

- Syntax

  ``` Python
  while condition:
      # Repeat this code block as long as the condition is true
      # Do something...
      if break_condition:
          break  # Leave the loop
      if continue_condition:
          continue  # Resume the loop without running the remaining code
      # Remaining code...
  else:
      # Run this code block if no break statement is run
  ```

- Example

  ``` Python
  def do_while_loop(iterable):
    count = 1
    while count <= len(iterable):
      upper = iterable[count - 1].upper()
      count += 1
      if upper == 'STOP':
        break
      if upper == 'CONT':
        continue
      print(upper)
    else:
      print('no break occured')
  ```

- REPL
  
  ``` Python
  # …/__learn-python-02-blogs/01.real-python> python3
  >>> import importlib
  >>> import py_02_while_loop_demo as demo
  >>> demo.do_while_loop(['aaa', 'bbb', 'cont', 'ccc'])
  AAA
  BBB
  CCC
  Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "/mnt/ntfs1/home.UserRus/Documents.Notes/__learn-python-02-blogs/01.real-python/py_02_while_loop_demo.py", line 4, in do_while_loop
      upper = iterable[count - 1].upper()
  IndexError: list index out of range
  # Bugfix!
  >>> importlib.reload(demo)
  <module 'py_02_while_loop_demo' from '/mnt/ntfs1/home.UserRus/Documents.Notes/__learn-python-02-blogs/01.real-python/py_02_while_loop_demo.py'>
  >>> demo.do_while_loop(['aaa', 'bbb', 'cont', 'stop', 'ccc'])
  AAA
  BBB
  >>> demo.do_while_loop(['aaa', 'bbb', 'cont', 'ccc'])
  AAA
  BBB
  CCC
  no break occured
  >>> demo.do_while_loop([])
  no break occured
  ```

- Note: Python **doesn’t have a `do-while loop`**.  
  … However, you can emulate this type of loop using a `while`.  
  … Check out [How Can You Emulate Do-While Loops in Python?](https://realpython.com/python-do-while/) to learn more.

- There are situations where you need an **infinite loop**.  
  … For example, *GUI applications* run in an *infinite loop*  
  … that manages the *user’s events*.
  
  This loop **needs a *break* statement** to terminate the loop  
  … when, for example, the user exits the application.  
  … You often create this type of [intentionally infinite loop](https://realpython.com/python-while-loop/#intentional-infinite-loops) using the **`while True:`** pattern.
